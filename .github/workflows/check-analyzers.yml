name: Check Roslyn Analyzer Versions

on:
  workflow_dispatch:
    inputs:
      nuget_package_id:
        description: 'NuGet package ID (e.g., Microsoft.Unity.Analyzers)'
        required: true
        type: string

jobs:
  check-versions:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout this repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Analyze each version
        shell: pwsh
        run: |
          $packageId = "${{ inputs.nuget_package_id }}"
          $packageIdLower = $packageId.ToLower()

          # Get versions using Registration API (excludes unlisted packages)
          $regUrl = "https://api.nuget.org/v3/registration5-gz-semver2/$packageIdLower/index.json"
          $regIndex = Invoke-RestMethod $regUrl

          $versions = @()

          foreach ($page in $regIndex.items) {
            # Check if page items are inline or need separate fetch
            $pageItems = $page.items
            if (-not $pageItems) {
              $pageData = Invoke-RestMethod $page.'@id'
              $pageItems = $pageData.items
            }

            foreach ($item in $pageItems) {
              $entry = $item.catalogEntry
              $version = $entry.version
              $listed = $entry.listed

              # Only include listed versions and exclude pre-releases
              if ($listed -and $version -notmatch '-') {
                $versions += $version
              }
            }
          }

          Write-Host "Package: $packageId"
          Write-Host "Found versions (excluding pre-releases and unlisted):"
          $versions | ForEach-Object { Write-Host "  $_" }

          # Result array
          $results = @()

          foreach ($version in $versions) {
            Write-Host "Processing version: $version"

            # Download nupkg
            $nupkgUrl = "https://api.nuget.org/v3-flatcontainer/$packageIdLower/$version/$packageIdLower.$version.nupkg"
            $nupkgPath = "package.nupkg"
            $extractPath = "package"

            try {
              Invoke-WebRequest -Uri $nupkgUrl -OutFile $nupkgPath -ErrorAction Stop

              # Extract
              if (Test-Path $extractPath) { Remove-Item -Recurse -Force $extractPath }
              Expand-Archive -Path $nupkgPath -DestinationPath $extractPath -Force

              # Find analyzer DLLs
              $dllFiles = Get-ChildItem -Path $extractPath -Filter "*.dll" -Recurse | Where-Object {
                $_.FullName -match "analyzers"
              }

              foreach ($dll in $dllFiles) {
                try {
                  # Load assembly and get references
                  $bytes = [System.IO.File]::ReadAllBytes($dll.FullName)
                  $assembly = [System.Reflection.Assembly]::Load($bytes)
                  $refs = $assembly.GetReferencedAssemblies()

                  # Find Microsoft.CodeAnalysis.CSharp reference
                  $csharpRef = $refs | Where-Object { $_.Name -eq "Microsoft.CodeAnalysis.CSharp" }

                  if ($csharpRef) {
                    $roslynVersion = $csharpRef.Version.ToString()
                    Write-Host "  Found: $($dll.Name) -> Roslyn $roslynVersion"

                    $results += [PSCustomObject]@{
                      Version = $version
                      RoslynVersion = $roslynVersion
                    }
                    break  # Only need one DLL per version
                  }
                } catch {
                  Write-Host "  Failed to load $($dll.Name): $_"
                }
              }

              # Cleanup
              Remove-Item -Force $nupkgPath -ErrorAction SilentlyContinue
              Remove-Item -Recurse -Force $extractPath -ErrorAction SilentlyContinue

            } catch {
              Write-Host "  Failed to download or process: $_"
            }
          }

          # Save results as JSON
          $results | ConvertTo-Json | Out-File -FilePath "version-data.json"
          Write-Host "Results saved to version-data.json"
          Get-Content "version-data.json"

      - name: Generate Markdown
        shell: pwsh
        run: |
          $packageId = "${{ inputs.nuget_package_id }}"
          $nugetUrl = "https://www.nuget.org/packages/$packageId"
          $outputFile = "$packageId.md"

          # Unity version thresholds (ordered for table column order)
          $unityVersions = [ordered]@{
            "Unity 2020.2" = [Version]"3.5.0.0"
            "Unity 2021.2" = [Version]"3.9.0.0"
            "Unity 2022.2" = [Version]"4.1.0.0"
            "Unity 6000.0" = [Version]"4.3.0.0"
          }

          # Read version data
          $data = Get-Content "version-data.json" | ConvertFrom-Json

          # Build markdown
          $md = @()
          $md += "# $packageId"
          $md += ""

          # Build header dynamically from $unityVersions keys
          $unityNames = @($unityVersions.Keys)
          $headerCells = @("Version", "Microsoft.CodeAnalysis.CSharp") + $unityNames
          $md += "| " + ($headerCells -join " | ") + " |"
          $separatorCells = @("---------", "-------------------------------") + ($unityNames | ForEach-Object { "--------------" })
          $md += "|" + ($separatorCells -join "|") + "|"

          # Sort by version descending
          $sortedData = $data | Sort-Object { [Version]$_.Version } -Descending

          foreach ($item in $sortedData) {
            $ver = $item.Version
            $roslyn = $item.RoslynVersion
            $roslynVer = [Version]$roslyn

            # Check compatibility dynamically for each Unity version
            $compatCells = foreach ($unityName in $unityNames) {
              if ($roslynVer -le $unityVersions[$unityName]) { "✅" } else { "❌" }
            }

            $md += "| [$ver]($nugetUrl/$ver) | $roslyn | " + ($compatCells -join " | ") + " |"
          }

          $md += ""
          $md += "> [!NOTE]  "
          $md += "> Newer versions of Microsoft.CodeAnalysis.CSharp may be backported to LTS releases. For example, Microsoft.CodeAnalysis.CSharp v4.3 is available in Unity 2022.3.12f1 and later."

          # Write file
          $md | Out-File -FilePath $outputFile -Encoding utf8
          Write-Host "Generated $outputFile"
          Get-Content $outputFile

      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PACKAGE_ID="${{ inputs.nuget_package_id }}"
          BRANCH_NAME="update-${PACKAGE_ID}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git checkout -b "$BRANCH_NAME"
          git add "${PACKAGE_ID}.md"
          git commit -m "Update ${PACKAGE_ID} version info"
          git push -u origin "$BRANCH_NAME" --force

          UPSTREAM_REPO=$(gh api "repos/${{ github.repository }}" --jq '.parent.full_name // empty')
          if [ -n "$UPSTREAM_REPO" ]; then
            # Running from a fork - show URL for manual PR creation in workflow summary
            PR_TITLE="Update ${PACKAGE_ID} version info"
            PR_BODY="This PR updates the version compatibility information for [${PACKAGE_ID}](https://www.nuget.org/packages/${PACKAGE_ID})."
            ENCODED_TITLE=$(printf '%s' "$PR_TITLE" | jq -sRr @uri)
            ENCODED_BODY=$(printf '%s' "$PR_BODY" | jq -sRr @uri)
            PR_URL="https://github.com/${UPSTREAM_REPO}/compare/master...${{ github.repository_owner }}:${BRANCH_NAME}?expand=1&title=${ENCODED_TITLE}&body=${ENCODED_BODY}"
            {
              echo "## Create a Pull Request"
              echo ""
              echo "This workflow was run from a forked repository."
              echo "Please create a Pull Request manually by clicking the link below:"
              echo ""
              echo "[Create Pull Request](${PR_URL})"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            # Running from the original repository - create PR directly
            gh pr create \
              --title "Update ${PACKAGE_ID} version info" \
              --body "This PR updates the version compatibility information for [${PACKAGE_ID}](https://www.nuget.org/packages/${PACKAGE_ID})." \
              --base master \
              --head "$BRANCH_NAME" || echo "PR already exists or failed to create"
          fi
